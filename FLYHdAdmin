local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local player = Players.LocalPlayer

-- Variáveis do Fly
local flyEnabled = false
local flying = false
local flySpeed = 50
local acceleration = 6
local rotationSmoothness = 4
local bodyVelocity, bodyGyro, flyConnection
local lastLookDirection = Vector3.new(0, 0, 0)
local firstActivation = true

-- Criar interface personalizada
local G2L = {}

-- ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling
G2L["ScreenGui_1"].ResetOnSpawn = false
CollectionService:AddTag(G2L["ScreenGui_1"], "main")

-- Frame principal
local mainFrame = Instance.new("Frame", G2L["ScreenGui_1"])
mainFrame.BackgroundColor3 = Color3.fromRGB(41, 41, 41)
mainFrame.Size = UDim2.new(0, 196, 0, 130)
mainFrame.Position = UDim2.new(0, 306, 0, 84)
mainFrame.BackgroundTransparency = 0.2
Instance.new("UICorner", mainFrame)

-- Adicionar UIDragDetector corretamente
local dragDetector = Instance.new("TextButton", mainFrame)
dragDetector.Size = UDim2.new(1, 0, 0, 26)
dragDetector.Position = UDim2.new(0, 0, 0, 0)
dragDetector.BackgroundTransparency = 1
dragDetector.Text = ""
dragDetector.ZIndex = 2

-- Cabeçalho
local header = Instance.new("TextLabel", mainFrame)
header.BackgroundColor3 = Color3.fromRGB(162, 8, 255)
header.Text = "FLY"
header.Size = UDim2.new(0, 196, 0, 26)
header.TextSize = 18
header.TextXAlignment = Enum.TextXAlignment.Left
header.TextColor3 = Color3.fromRGB(0, 0, 0)
header.Font = Enum.Font.SourceSansBold
Instance.new("UICorner", header).CornerRadius = UDim.new(0, 2)

-- Botão Minimizar dentro do cabeçalho
local minimizeButton = Instance.new("TextButton", header)
minimizeButton.Size = UDim2.new(0, 24, 0, 20)
minimizeButton.Position = UDim2.new(1, -28, 0, 3)
minimizeButton.BackgroundColor3 = Color3.fromRGB(192, 0, 255)
minimizeButton.BackgroundTransparency = 0.15
minimizeButton.Text = "-"
minimizeButton.TextSize = 18
minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeButton.Font = Enum.Font.SourceSansBold
Instance.new("UICorner", minimizeButton).CornerRadius = UDim.new(0, 3)

-- Botão Toggle Fly
local toggleButton = Instance.new("TextButton", mainFrame)
toggleButton.Size = UDim2.new(0, 146, 0, 30)
toggleButton.Position = UDim2.new(0, 22, 0, 42)
toggleButton.Text = "ENABLE"
toggleButton.TextSize = 14
toggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
toggleButton.BackgroundColor3 = Color3.fromRGB(144, 0, 255)
toggleButton.Font = Enum.Font.SourceSansBold
Instance.new("UICorner", toggleButton)

-- Label Speed
local speedLabel = Instance.new("TextLabel", mainFrame)
speedLabel.Text = "Speed"
speedLabel.Size = UDim2.new(0, 76, 0, 24)
speedLabel.Position = UDim2.new(0, 26, 0, 90)
speedLabel.TextSize = 18
speedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
speedLabel.BackgroundTransparency = 1

-- TextBox Speed
local speedTextBox = Instance.new("TextBox", mainFrame)
speedTextBox.Size = UDim2.new(0, 50, 0, 26)
speedTextBox.Position = UDim2.new(0, 120, 0, 90)
speedTextBox.Text = tostring(flySpeed)
speedTextBox.TextSize = 14
speedTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
speedTextBox.BackgroundColor3 = Color3.fromRGB(131, 0, 187)
speedTextBox.BackgroundTransparency = 0.19

-- Variável minimizar
local isMinimized = false
local originalSize = mainFrame.Size

-- Lista para armazenar os elementos que serão escondidos
local elementsToHide = {toggleButton, speedLabel, speedTextBox}

local function toggleMinimize()
    isMinimized = not isMinimized
    if isMinimized then
        for _, element in ipairs(elementsToHide) do
            element.Visible = false
        end
        mainFrame.Size = UDim2.new(0, 196, 0, 26)
        minimizeButton.Text = "+"
    else
        for _, element in ipairs(elementsToHide) do
            element.Visible = true
        end
        mainFrame.Size = originalSize
        minimizeButton.Text = "-"
    end
end

-- Configurar o arrasto da janela
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

dragDetector.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

dragDetector.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Funções auxiliares Fly
local function getCharacter() return player.Character or player.CharacterAdded:Wait() end
local function getRootPart() return getCharacter():FindFirstChild("HumanoidRootPart") end
local function enableNoclip()
    for _, part in ipairs(getCharacter():GetDescendants()) do
        if part:IsA("BasePart") then part.CanCollide = false end
    end
end

-- SISTEMA DE CONTROLE AVANÇADO COM SUPORTE A JOYSTICK/MOBILE
local function waitForControlModule()
    local playerModule = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")
    return require(playerModule):GetControls()
end

-- SISTEMA DE DETECÇÃO DE INPUT MELHORADO
local function getInputVector(controlModule)
    -- Método 1: ControlModule (mais confiável)
    local moveVector = Vector3.new(0, 0, 0)
    
    if controlModule then
        local success, controlVector = pcall(function()
            return controlModule:GetMoveVector()
        end)
        if success and controlVector and controlVector.Magnitude > 0.05 then
            return controlVector
        end
    end
    
    -- Método 2: Humanoid.MoveDirection (fallback)
    local character = getCharacter()
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MoveDirection.Magnitude > 0.05 then
            return humanoid.MoveDirection
        end
    end
    
    -- Método 3: Detecção manual de teclado (último recurso)
    local keyboardVector = Vector3.new(0, 0, 0)
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        keyboardVector = keyboardVector + Vector3.new(0, 0, 1)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        keyboardVector = keyboardVector + Vector3.new(0, 0, -1)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        keyboardVector = keyboardVector + Vector3.new(-1, 0, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        keyboardVector = keyboardVector + Vector3.new(1, 0, 0)
    end
    
    if keyboardVector.Magnitude > 0 then
        return keyboardVector.Unit
    end
    
    return Vector3.new(0, 0, 0)
end

-- Start Fly com Sistema de Câmera Melhorado
local function startFly()
    local root = getRootPart()
    if not root then return end
    flying = true
    
    -- Limpar objetos anteriores
    if bodyVelocity then bodyVelocity:Destroy() end
    if bodyGyro then bodyGyro:Destroy() end

    -- Criar BodyVelocity
    bodyVelocity = Instance.new("BodyVelocity", root)
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    -- Criar BodyGyro
    bodyGyro = Instance.new("BodyGyro", root)
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 5e3
    bodyGyro.D = 500
    bodyGyro.CFrame = root.CFrame

    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end

    -- Inicializar módulo de controle
    local controlModule = waitForControlModule()
    local camera = workspace.CurrentCamera
    lastLookDirection = camera.CFrame.LookVector

    -- Desconectar conexão anterior
    if flyConnection then flyConnection:Disconnect() end
    
    -- LOOP PRINCIPAL DO FLY COM SISTEMA DE CÂMERA AVANÇADO
    flyConnection = RunService.Heartbeat:Connect(function(dt)
        if not flyEnabled or not flying then return end
        
        -- Obter vetor de movimento usando sistema robusto
        local moveVec = getInputVector(controlModule)
        local targetVelocity = Vector3.zero
        
        -- Calcular velocidade baseada no movimento e câmera
        if moveVec.Magnitude > 0 then
            -- Transformar movimento local para espaço mundial baseado na câmera
            local cameraCFrame = camera.CFrame
            local worldMoveVector = cameraCFrame:VectorToWorldSpace(moveVec)
            targetVelocity = worldMoveVector.Unit * flySpeed * moveVec.Magnitude
        end
        
        -- Aplicar movimento vertical (Space/Shift)
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            targetVelocity = targetVelocity + Vector3.new(0, flySpeed, 0)
        elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            targetVelocity = targetVelocity + Vector3.new(0, -flySpeed, 0)
        end
        
        -- Aplicar aceleração suave
        local currentVelocity = bodyVelocity.Velocity
        local smoothedVelocity = currentVelocity:Lerp(targetVelocity, math.clamp(dt * acceleration, 0, 1))
        bodyVelocity.Velocity = smoothedVelocity
        
        -- SISTEMA DE ROTAÇÃO BASEADO NA CÂMERA (SUAVE)
        local currentLookDirection = camera.CFrame.LookVector
        local smoothedLook = lastLookDirection:Lerp(currentLookDirection, math.clamp(dt * rotationSmoothness, 0, 1))
        lastLookDirection = smoothedLook
        
        -- Aplicar rotação com inclinação baseada no movimento
        local targetCFrame = CFrame.lookAt(root.Position, root.Position + smoothedLook)
        
        -- Inclinação dinâmica pela cabeça/câmera
        if smoothedVelocity.Magnitude > 5 then
            local cameraLook = camera.CFrame.LookVector
            local moveDir = smoothedVelocity.Unit

            -- Inclinação para frente/trás baseada na direção da cabeça/câmera
            local forwardAmount = moveDir:Dot(cameraLook)
            local pitch = math.clamp(-forwardAmount * 0.5, -0.7, 0.7) -- negativo: inclina pra frente, positivo: pra trás

            -- Inclinação lateral pelos lados
            local rightVector = camera.CFrame.RightVector
            local sideAmount = moveDir:Dot(rightVector)
            local roll = math.clamp(-sideAmount * 0.3, -0.4, 0.4)

            targetCFrame = targetCFrame * CFrame.Angles(pitch, 0, roll)
        end
        
        -- Aplicar rotação suave
        bodyGyro.CFrame = bodyGyro.CFrame:Lerp(targetCFrame, math.clamp(dt * rotationSmoothness, 0, 1))
        
        -- Manter noclip
        enableNoclip()
    end)
end

-- Stop Fly
local function stopFly()
    flying = false
    if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
    if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
    if flyConnection then flyConnection:Disconnect() flyConnection = nil end
    
    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
    
    -- Restaurar colisão
    local character = getCharacter()
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end
end

-- Eventos Interface
toggleButton.MouseButton1Click:Connect(function()
    flyEnabled = not flyEnabled
    if flyEnabled then
        toggleButton.Text = "DISABLE"
        toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        startFly()
    else
        toggleButton.Text = "ENABLE"
        toggleButton.BackgroundColor3 = Color3.fromRGB(144, 0, 255)
        stopFly()
    end
end)

speedTextBox.FocusLost:Connect(function()
    local newSpeed = tonumber(speedTextBox.Text)
    if newSpeed and newSpeed > 0 and newSpeed <= 500 then 
        flySpeed = newSpeed 
    else 
        speedTextBox.Text = tostring(flySpeed) 
    end
end)

minimizeButton.MouseButton1Click:Connect(toggleMinimize)

-- Toggle com tecla F
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.F then
        toggleButton:Activate()
    end
end)

-- Reaplicar após respawn
player.CharacterAdded:Connect(function()
    task.wait(1)
    if flyEnabled then startFly() end
end)

-- Limpeza ao sair
game:BindToClose(function()
    if flying then stopFly() end
end)        mainFrame.Size = UDim2.new(0, 196, 0, 26)
        minimizeButton.Text = "+"
    else
        for _, element in ipairs(elementsToHide) do
            element.Visible = true
        end
        mainFrame.Size = originalSize
        minimizeButton.Text = "-"
    end
end

-- Configurar o arrasto da janela
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

dragDetector.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

dragDetector.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Funções auxiliares Fly
local function getCharacter() return player.Character or player.CharacterAdded:Wait() end
local function getRootPart() return getCharacter():FindFirstChild("HumanoidRootPart") end
local function enableNoclip()
    for _, part in ipairs(getCharacter():GetDescendants()) do
        if part:IsA("BasePart") then part.CanCollide = false end
    end
end

local function waitForControlModule()
    local playerModule = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")
    return require(playerModule):GetControls()
end

-- Start Fly
local function startFly()
    local root = getRootPart()
    if not root then return end
    flying = true
    if bodyVelocity then bodyVelocity:Destroy() end
    if bodyGyro then bodyGyro:Destroy() end

    bodyVelocity = Instance.new("BodyVelocity", root)
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    bodyGyro = Instance.new("BodyGyro", root)
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 5e3
    bodyGyro.CFrame = root.CFrame

    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end

    local controlModule = waitForControlModule()
    local camera = workspace.CurrentCamera
    lastLookDirection = camera.CFrame.LookVector

    if flyConnection then flyConnection:Disconnect() end
    flyConnection = RunService.Heartbeat:Connect(function(dt)
        if not flyEnabled then return end
        local moveVec = controlModule and controlModule:GetMoveVector() or Vector3.zero
        local targetVelocity = Vector3.zero
        if moveVec.Magnitude > 0 then
            targetVelocity = camera.CFrame:VectorToWorldSpace(moveVec).Unit * flySpeed
        end
        bodyVelocity.Velocity = bodyVelocity.Velocity:Lerp(targetVelocity, math.clamp(dt * acceleration, 0, 1))
        local smoothedLook = lastLookDirection:Lerp(camera.CFrame.LookVector, math.clamp(dt * rotationSmoothness, 0, 1))
        lastLookDirection = smoothedLook
        bodyGyro.CFrame = CFrame.lookAt(root.Position, root.Position + smoothedLook)
        enableNoclip()
    end)
end

-- Stop Fly
local function stopFly()
    flying = false
    if bodyVelocity then bodyVelocity:Destroy() bodyVelocity=nil end
    if bodyGyro then bodyGyro:Destroy() bodyGyro=nil end
    if flyConnection then flyConnection:Disconnect() flyConnection=nil end
    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

-- Eventos Interface
toggleButton.MouseButton1Click:Connect(function()
    flyEnabled = not flyEnabled
    if flyEnabled then
        toggleButton.Text = "DISABLE"
        toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        startFly()
    else
        toggleButton.Text = "ENABLE"
        toggleButton.BackgroundColor3 = Color3.fromRGB(144, 0, 255)
        stopFly()
    end
end)

speedTextBox.FocusLost:Connect(function()
    local newSpeed = tonumber(speedTextBox.Text)
    if newSpeed and newSpeed > 0 then flySpeed = newSpeed else speedTextBox.Text = tostring(flySpeed) end
end)

minimizeButton.MouseButton1Click:Connect(toggleMinimize)

-- Toggle com tecla F
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.F then
        toggleButton:Activate()
    end
end)

-- Reaplicar após respawn
player.CharacterAdded:Connect(function()
    task.wait(1)
    if flyEnabled then startFly() end
end)


-- msg bah

--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 

designed using localmaze gui creator
]=]

-- Instances: 7 | Scripts: 0 | Modules: 0 | Tags: 1
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local G2L = {}

-- Players.maykon_adm.PlayerGui.ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling

-- Tags
CollectionService:AddTag(G2L["ScreenGui_1"], [[main]])

-- Players.maykon_adm.PlayerGui.ScreenGui.Frame
G2L["Frame_2"] = Instance.new("Frame", G2L["ScreenGui_1"])
G2L["Frame_2"]["BorderSizePixel"] = 0
G2L["Frame_2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["Frame_2"]["Size"] = UDim2.new(0, 196, 0, 100)
-- Posição inicial: fora da tela (embaixo e à direita)
G2L["Frame_2"]["Position"] = UDim2.new(1, 50, 1, 50)
G2L["Frame_2"]["BackgroundTransparency"] = 0.19

-- Players.maykon_adm.PlayerGui.ScreenGui.Frame.Bah msg
G2L["Bah msg_3"] = Instance.new("TextLabel", G2L["Frame_2"])
G2L["Bah msg_3"]["BorderSizePixel"] = 0
G2L["Bah msg_3"]["TextSize"] = 24
G2L["Bah msg_3"]["BackgroundColor3"] = Color3.fromRGB(149, 14, 255)
G2L["Bah msg_3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Guru.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal)
G2L["Bah msg_3"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
G2L["Bah msg_3"]["Size"] = UDim2.new(0, 196, 0, 24)
G2L["Bah msg_3"]["Text"] = [[Bah's Message]]
G2L["Bah msg_3"]["Name"] = [[Bah msg]]

-- Players.maykon_adm.PlayerGui.ScreenGui.Frame.Bah msg.text1
G2L["text1_4"] = Instance.new("TextLabel", G2L["Bah msg_3"])
G2L["text1_4"]["BorderSizePixel"] = 0
G2L["text1_4"]["TextSize"] = 10
G2L["text1_4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["text1_4"]["TextDirection"] = Enum.TextDirection.LeftToRight
G2L["text1_4"]["TextColor3"] = Color3.fromRGB(156, 0, 255)
G2L["text1_4"]["BackgroundTransparency"] = 9
G2L["text1_4"]["Size"] = UDim2.new(0, 186, 0, 16)
G2L["text1_4"]["Text"] = [[this script was created by Bah]]
G2L["text1_4"]["Name"] = [[text1]]
G2L["text1_4"]["Position"] = UDim2.new(0, 6, 0, 28)

-- Players.maykon_adm.PlayerGui.ScreenGui.Frame.Bah msg.text1.text2
G2L["text2_5"] = Instance.new("TextLabel", G2L["text1_4"])
G2L["text2_5"]["BorderSizePixel"] = 0
G2L["text2_5"]["TextSize"] = 10
G2L["text2_5"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["text2_5"]["TextDirection"] = Enum.TextDirection.LeftToRight
G2L["text2_5"]["TextColor3"] = Color3.fromRGB(156, 0, 255)
G2L["text2_5"]["BackgroundTransparency"] = 9
G2L["text2_5"]["Size"] = UDim2.new(0, 186, 0, 16)
G2L["text2_5"]["Text"] = [[Join the gang's discord]]
G2L["text2_5"]["Name"] = [[text2]]
G2L["text2_5"]["Position"] = UDim2.new(0, 2, 0, 18)

-- Players.maykon_adm.PlayerGui.ScreenGui.Frame.Bah msg.text1.text2.discordInvite
G2L["discordInvite_6"] = Instance.new("TextLabel", G2L["text2_5"])
G2L["discordInvite_6"]["BorderSizePixel"] = 0
G2L["discordInvite_6"]["TextSize"] = 10
G2L["discordInvite_6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["discordInvite_6"]["TextDirection"] = Enum.TextDirection.LeftToRight
G2L["discordInvite_6"]["TextColor3"] = Color3.fromRGB(156, 0, 255)
G2L["discordInvite_6"]["BackgroundTransparency"] = 9
G2L["discordInvite_6"]["Size"] = UDim2.new(0, 186, 0, 16)
G2L["discordInvite_6"]["Text"] = [[https://discord.gg/a3R8FnbY]]
G2L["discordInvite_6"]["Name"] = [[discordInvite]]
G2L["discordInvite_6"]["Position"] = UDim2.new(0, -4, 0, 26)

-- Players.maykon_adm.PlayerGui.ScreenGui.Frame.TextButton
G2L["TextButton_7"] = Instance.new("TextButton", G2L["Frame_2"])
G2L["TextButton_7"]["BorderSizePixel"] = 0
G2L["TextButton_7"]["TextSize"] = 24
G2L["TextButton_7"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
G2L["TextButton_7"]["BackgroundColor3"] = Color3.fromRGB(89, 0, 149)
G2L["TextButton_7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal)
G2L["TextButton_7"]["Size"] = UDim2.new(0, 22, 0, 20)
G2L["TextButton_7"]["Text"] = [[X]]
G2L["TextButton_7"]["Position"] = UDim2.new(0, 166, 0, 2)

-- Função para copiar o link do Discord
local function copyDiscordLink()
    local discordLink = "https://discord.gg/a3R8FnbY"
    
    -- Tentar copiar para a área de transferência
    if setclipboard then
        setclipboard(discordLink)
        print("Link do Discord copiado para a área de transferência!")
    elseif toclipboard then
        toclipboard(discordLink)
        print("Link do Discord copiado para a área de transferência!")
    else
        print("Função de cópia não disponível. Link: " .. discordLink)
    end
end

-- Função para animar a entrada da mensagem
local function animateIn()
    -- Configurações da animação de entrada
    local tweenInfo = TweenInfo.new(
        1.2, -- Duração (segundos)
        Enum.EasingStyle.Quart, -- Estilo de easing
        Enum.EasingDirection.Out, -- Direção do easing
        0, -- Repetições
        false, -- Reverso
        0 -- Delay
    )
    
    -- Posição final: canto inferior direito da tela
    local targetPosition = UDim2.new(1, -210, 1, -110) -- Margem de 10px das bordas
    
    -- Criar e iniciar a animação
    local tween = TweenService:Create(G2L["Frame_2"], tweenInfo, {Position = targetPosition})
    tween:Play()
    
    -- Quando a animação de entrada terminar
    tween.Completed:Connect(function()
        wait(0.5) -- Pequena pausa antes de mostrar completamente
        
        -- Copiar automaticamente o link do Discord
        copyDiscordLink()
        
        -- Aguardar 5 segundos e depois fechar automaticamente
        wait(5)
        animateOut()
    end)
end

-- Função para animar a saída da mensagem
local function animateOut()
    -- Configurações da animação de saída
    local tweenInfo = TweenInfo.new(
        0.8, -- Duração (segundos)
        Enum.EasingStyle.Quart, -- Estilo de easing
        Enum.EasingDirection.In, -- Direção do easing
        0, -- Repetições
        false, -- Reverso
        0 -- Delay
    )
    
    -- Posição de saída: fora da tela pela direita
    local exitPosition = UDim2.new(1, 50, 1, -110)
    
    -- Criar e iniciar a animação de saída
    local tween = TweenService:Create(G2L["Frame_2"], tweenInfo, {Position = exitPosition})
    tween:Play()
    
    -- Destruir a GUI após a animação
    tween.Completed:Connect(function()
        G2L["ScreenGui_1"]:Destroy()
    end)
end

-- Conectar o botão X à função de saída
G2L["TextButton_7"].MouseButton1Click:Connect(animateOut)

-- Iniciar a animação de entrada quando o script é executado
wait(0.1) -- Pequeno delay para garantir que tudo foi carregado
animateIn()

return G2L["ScreenGui_1"], require
