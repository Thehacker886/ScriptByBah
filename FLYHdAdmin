local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local player = Players.LocalPlayer

-- Variáveis do Fly
local flyEnabled = false
local flying = false
local flySpeed = 50
local acceleration = 6
local rotationSmoothness = 4
local bodyVelocity, bodyGyro, flyConnection
local lastLookDirection = Vector3.new(0, 0, 0)
local firstActivation = true

-- Criar interface personalizada
local G2L = {}

-- ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling
G2L["ScreenGui_1"].ResetOnSpawn = false
CollectionService:AddTag(G2L["ScreenGui_1"], "main")

-- Frame principal
local mainFrame = Instance.new("Frame", G2L["ScreenGui_1"])
mainFrame.BackgroundColor3 = Color3.fromRGB(41, 41, 41)
mainFrame.Size = UDim2.new(0, 196, 0, 130)
mainFrame.Position = UDim2.new(0, 306, 0, 84)
mainFrame.BackgroundTransparency = 0.2
Instance.new("UICorner", mainFrame)

-- Adicionar UIDragDetector corretamente
local dragDetector = Instance.new("TextButton", mainFrame)
dragDetector.Size = UDim2.new(1, 0, 0, 26)
dragDetector.Position = UDim2.new(0, 0, 0, 0)
dragDetector.BackgroundTransparency = 1
dragDetector.Text = ""
dragDetector.ZIndex = 2

-- Cabeçalho
local header = Instance.new("TextLabel", mainFrame)
header.BackgroundColor3 = Color3.fromRGB(162, 8, 255)
header.Text = "FLY"
header.Size = UDim2.new(0, 196, 0, 26)
header.TextSize = 18
header.TextXAlignment = Enum.TextXAlignment.Left
header.TextColor3 = Color3.fromRGB(0, 0, 0)
header.Font = Enum.Font.SourceSansBold
Instance.new("UICorner", header).CornerRadius = UDim.new(0, 2)

-- Botão Minimizar dentro do cabeçalho
local minimizeButton = Instance.new("TextButton", header)
minimizeButton.Size = UDim2.new(0, 24, 0, 20)
minimizeButton.Position = UDim2.new(1, -28, 0, 3)
minimizeButton.BackgroundColor3 = Color3.fromRGB(192, 0, 255)
minimizeButton.BackgroundTransparency = 0.15
minimizeButton.Text = "-"
minimizeButton.TextSize = 18
minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeButton.Font = Enum.Font.SourceSansBold
Instance.new("UICorner", minimizeButton).CornerRadius = UDim.new(0, 3)

-- Botão Toggle Fly
local toggleButton = Instance.new("TextButton", mainFrame)
toggleButton.Size = UDim2.new(0, 146, 0, 30)
toggleButton.Position = UDim2.new(0, 22, 0, 42)
toggleButton.Text = "ENABLE"
toggleButton.TextSize = 14
toggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
toggleButton.BackgroundColor3 = Color3.fromRGB(144, 0, 255)
toggleButton.Font = Enum.Font.SourceSansBold
Instance.new("UICorner", toggleButton)

-- Label Speed
local speedLabel = Instance.new("TextLabel", mainFrame)
speedLabel.Text = "Speed"
speedLabel.Size = UDim2.new(0, 76, 0, 24)
speedLabel.Position = UDim2.new(0, 26, 0, 90)
speedLabel.TextSize = 18
speedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
speedLabel.BackgroundTransparency = 1

-- TextBox Speed
local speedTextBox = Instance.new("TextBox", mainFrame)
speedTextBox.Size = UDim2.new(0, 50, 0, 26)
speedTextBox.Position = UDim2.new(0, 120, 0, 90)
speedTextBox.Text = tostring(flySpeed)
speedTextBox.TextSize = 14
speedTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
speedTextBox.BackgroundColor3 = Color3.fromRGB(131, 0, 187)
speedTextBox.BackgroundTransparency = 0.19

-- Variável minimizar
local isMinimized = false
local originalSize = mainFrame.Size

-- Lista para armazenar os elementos que serão escondidos
local elementsToHide = {toggleButton, speedLabel, speedTextBox}

local function toggleMinimize()
    isMinimized = not isMinimized
    if isMinimized then
        for _, element in ipairs(elementsToHide) do
            element.Visible = false
        end
        mainFrame.Size = UDim2.new(0, 196, 0, 26)
        minimizeButton.Text = "+"
    else
        for _, element in ipairs(elementsToHide) do
            element.Visible = true
        end
        mainFrame.Size = originalSize
        minimizeButton.Text = "-"
    end
end

-- Configurar o arrasto da janela
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

dragDetector.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

dragDetector.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Funções auxiliares Fly
local function getCharacter() return player.Character or player.CharacterAdded:Wait() end
local function getRootPart() return getCharacter():FindFirstChild("HumanoidRootPart") end
local function enableNoclip()
    for _, part in ipairs(getCharacter():GetDescendants()) do
        if part:IsA("BasePart") then part.CanCollide = false end
    end
end

-- SISTEMA DE CONTROLE AVANÇADO COM SUPORTE A JOYSTICK/MOBILE
local function waitForControlModule()
    local playerModule = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")
    return require(playerModule):GetControls()
end

-- SISTEMA DE DETECÇÃO DE INPUT MELHORADO
local function getInputVector(controlModule)
    -- Método 1: ControlModule (mais confiável)
    local moveVector = Vector3.new(0, 0, 0)
    
    if controlModule then
        local success, controlVector = pcall(function()
            return controlModule:GetMoveVector()
        end)
        if success and controlVector and controlVector.Magnitude > 0.05 then
            return controlVector
        end
    end
    
    -- Método 2: Humanoid.MoveDirection (fallback)
    local character = getCharacter()
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MoveDirection.Magnitude > 0.05 then
            return humanoid.MoveDirection
        end
    end
    
    -- Método 3: Detecção manual de teclado (último recurso)
    local keyboardVector = Vector3.new(0, 0, 0)
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        keyboardVector = keyboardVector + Vector3.new(0, 0, 1)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        keyboardVector = keyboardVector + Vector3.new(0, 0, -1)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        keyboardVector = keyboardVector + Vector3.new(-1, 0, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        keyboardVector = keyboardVector + Vector3.new(1, 0, 0)
    end
    
    if keyboardVector.Magnitude > 0 then
        return keyboardVector.Unit
    end
    
    return Vector3.new(0, 0, 0)
end

-- Start Fly com Sistema de Câmera Melhorado
local function startFly()
    local root = getRootPart()
    if not root then return end
    flying = true
    
    -- Limpar objetos anteriores
    if bodyVelocity then bodyVelocity:Destroy() end
    if bodyGyro then bodyGyro:Destroy() end

    -- Criar BodyVelocity
    bodyVelocity = Instance.new("BodyVelocity", root)
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    -- Criar BodyGyro
    bodyGyro = Instance.new("BodyGyro", root)
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 5e3
    bodyGyro.D = 500
    bodyGyro.CFrame = root.CFrame

    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end

    -- Inicializar módulo de controle
    local controlModule = waitForControlModule()
    local camera = workspace.CurrentCamera
    lastLookDirection = camera.CFrame.LookVector

    -- Desconectar conexão anterior
    if flyConnection then flyConnection:Disconnect() end
    
    -- LOOP PRINCIPAL DO FLY COM SISTEMA DE CÂMERA AVANÇADO
    flyConnection = RunService.Heartbeat:Connect(function(dt)
        if not flyEnabled or not flying then return end
        
        -- Obter vetor de movimento usando sistema robusto
        local moveVec = getInputVector(controlModule)
        local targetVelocity = Vector3.zero
        
        -- Calcular velocidade baseada no movimento e câmera
        if moveVec.Magnitude > 0 then
            -- Transformar movimento local para espaço mundial baseado na câmera
            local cameraCFrame = camera.CFrame
            local worldMoveVector = cameraCFrame:VectorToWorldSpace(moveVec)
            targetVelocity = worldMoveVector.Unit * flySpeed * moveVec.Magnitude
        end
        
        -- Aplicar movimento vertical (Space/Shift)
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            targetVelocity = targetVelocity + Vector3.new(0, flySpeed, 0)
        elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            targetVelocity = targetVelocity + Vector3.new(0, -flySpeed, 0)
        end
        
        -- Aplicar aceleração suave
        local currentVelocity = bodyVelocity.Velocity
        local smoothedVelocity = currentVelocity:Lerp(targetVelocity, math.clamp(dt * acceleration, 0, 1))
        bodyVelocity.Velocity = smoothedVelocity
        
        -- SISTEMA DE ROTAÇÃO BASEADO NA CÂMERA (SUAVE)
        local currentLookDirection = camera.CFrame.LookVector
        local smoothedLook = lastLookDirection:Lerp(currentLookDirection, math.clamp(dt * rotationSmoothness, 0, 1))
        lastLookDirection = smoothedLook
        
        -- Aplicar rotação com inclinação baseada no movimento
        local targetCFrame = CFrame.lookAt(root.Position, root.Position + smoothedLook)
        
        -- Inclinação dinâmica pela cabeça/câmera
        if smoothedVelocity.Magnitude > 5 then
            local cameraLook = camera.CFrame.LookVector
            local moveDir = smoothedVelocity.Unit

            -- Inclinação para frente/trás baseada na direção da cabeça/câmera
            local forwardAmount = moveDir:Dot(cameraLook)
            local pitch = math.clamp(-forwardAmount * 0.5, -0.7, 0.7) -- negativo: inclina pra frente, positivo: pra trás

            -- Inclinação lateral pelos lados
            local rightVector = camera.CFrame.RightVector
            local sideAmount = moveDir:Dot(rightVector)
            local roll = math.clamp(-sideAmount * 0.3, -0.4, 0.4)

            targetCFrame = targetCFrame * CFrame.Angles(pitch, 0, roll)
        end
        
        -- Aplicar rotação suave
        bodyGyro.CFrame = bodyGyro.CFrame:Lerp(targetCFrame, math.clamp(dt * rotationSmoothness, 0, 1))
        
        -- Manter noclip
        enableNoclip()
    end)
end

-- Stop Fly
local function stopFly()
    flying = false
    if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
    if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
    if flyConnection then flyConnection:Disconnect() flyConnection = nil end
    
    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
    
    -- Restaurar colisão
    local character = getCharacter()
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end
end

-- Eventos Interface
toggleButton.MouseButton1Click:Connect(function()
    flyEnabled = not flyEnabled
    if flyEnabled then
        toggleButton.Text = "DISABLE"
        toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        startFly()
    else
        toggleButton.Text = "ENABLE"
        toggleButton.BackgroundColor3 = Color3.fromRGB(144, 0, 255)
        stopFly()
    end
end)

speedTextBox.FocusLost:Connect(function()
    local newSpeed = tonumber(speedTextBox.Text)
    if newSpeed and newSpeed > 0 and newSpeed <= 500 then 
        flySpeed = newSpeed 
    else 
        speedTextBox.Text = tostring(flySpeed) 
    end
end)

minimizeButton.MouseButton1Click:Connect(toggleMinimize)

-- Toggle com tecla F
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.F then
        toggleButton:Activate()
    end
end)

-- Reaplicar após respawn
player.CharacterAdded:Connect(function()
    task.wait(1)
    if flyEnabled then startFly() end
end)

-- Limpeza ao sair
game:BindToClose(function()
    if flying then stopFly() end
end)
